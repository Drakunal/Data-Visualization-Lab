library('tidyverse')

#---------------------------------------------------------
#Statistical Transformation
#---------------------------------------------------------
diamonds
#The following chart displays the total number of 
#diamonds in the diamonds dataset, grouped by cut. 
#The diamonds dataset comes in ggplot2 and contains 
#information about ~54,000 diamonds, 
#including the price, carat, color, clarity, and cut 
#of each diamond.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))


#On the x-axis, the chart displays cut, 
#a variable from diamonds. On the y-axis, it displays count, 
#but count is not a variable in diamonds! 
#Where does count come from? Many graphs, like scatterplots, 
#plot the raw values of your dataset. 
#Other graphs, like bar charts, calculate new values to plot:

# 1) bar charts, histograms, and frequency polygons 
#bin your data and then plot bin counts, the number 
#of points that fall in each bin.

# 2) smoothers fit a model to your data and then plot 
#predictions from the model.

# 3) boxplots compute a robust summary of the 
#distribution and then display a specially formatted box.


#The algorithm used to calculate new values for a graph 
#is called a stat, short for statistical transformation.


#You can learn which stat a geom uses by inspecting 
#the default value for the stat argument. 
#For example, ?geom_bar shows that the default value 
#for stat is “count”, which means that geom_bar() 
#uses stat_count()


#You can generally use geoms and stats interchangeably. 
#For example, you can recreate the previous 
#plot using stat_count() instead of geom_bar()

?geom_bar()
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))

#This works because every geom has a default stat; 
#and every stat has a default geom. 
#This means that you can typically use geoms without 
#worrying about the underlying statistical 
#transformation. There are three reasons you might 
#need to use a stat explicitly:


# 1)You might want to override the default stat. 
#In the code below, I changed the stat of geom_bar() 
#from count (the default) to identity. 
#This lets me map the height of the bars to the 
#raw values of a y variable. Unfortunately 
#when people talk about bar charts casually, 
#they might be referring to this type of bar chart, 
#where the height of the bar is already present in 
#the data, or the previous bar chart where the 
#height of the bar is generated by counting rows.



#A tribble () is used for creating a 
#row-wise, readable tibble in R. 
#This is useful for creating small tables of data. 
#*Syntax: tribble (~column1, ~column2)*
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)

ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")





# 2) You might want to override the default mapping 
#from transformed variables to aesthetics. 
#For example, you might want to display a bar chart 
#of proportion, rather than count:
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))



# 3)You might want to draw greater attention 
#to the statistical transformation in your code. 
#For example, you might use stat_summary(), 
#which summarises the y values for each unique x value, 
#to draw attention to the summary that you’re computing:
?stat_summary()
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )


#----------------------------------------------------
#Heatmap
#----------------------------------------------------
#A heatmap is a graphical representation of data where
#the individual values contained in a matrix are 
#represented as colors. It is a bit like looking a 
#data table from above.


#using ggplot2
# Dummy data
x <- LETTERS[1:20]
x
y <- paste0("var", seq(1,20))
y
data <- expand.grid(X=x, Y=y)
data
#The runif() function generates random 
#deviates of the uniform distribution 
#and is written as runif(n, min = 0, max = 1) . 
#We may easily generate n number of random samples 
#within any interval, defined by the min and 
#the max argument.
data$Z <- runif(400, 0, 5)

# Heatmap 
ggplot(data, aes(X, Y, fill= Z)) + 
  geom_tile()


install.packages('hrbrthemes')
library(hrbrthemes)

# Dummy data
x <- LETTERS[1:20]
y <- paste0("var", seq(1,20))
data <- expand.grid(X=x, Y=y)
data$Z <- runif(400, 0, 5)

# Give extreme colors:
ggplot(data, aes(X, Y, fill= Z)) + 
  geom_tile() +
  scale_fill_gradient(low="white", high="blue") +
  theme_ipsum()
?scale_fill_gradient()
?theme_ipsum()


# Color Brewer palette
ggplot(data, aes(X, Y, fill= Z)) + 
  geom_tile() +
  scale_fill_distiller(palette = "RdPu") +
  theme_ipsum()
?scale_fill_distiller()
# Color Brewer palette
install.packages('viridis')
library(viridis)
ggplot(data, aes(X, Y, fill= Z)) + 
  geom_tile() +
  scale_fill_viridis(discrete=FALSE) +
  theme_ipsum()

?scale_fill_viridis()

# Volcano dataset
#volcano

# Heatmap 
volcano %>%
  
  # Data wrangling
  as_tibble() %>%
  rowid_to_column(var="X") %>%
  gather(key="Y", value="Z", -1) %>%
  
  # Change Y to numeric
  mutate(Y=as.numeric(gsub("V","",Y))) %>%
  
  # Viz
  ggplot(aes(X, Y, fill= Z)) + 
  geom_tile() +
  theme_ipsum() +
  theme(legend.position="none")


install.packages('plotly')
library(plotly)
# Dummy data
x <- LETTERS[1:20]
y <- paste0("var", seq(1,20))
data <- expand.grid(X=x, Y=y)
data$Z <- runif(400, 0, 5)

# new column: text for tooltip:
data <- data %>%
  mutate(text = paste0("x: ", x, "\n", "y: ", y, "\n", "Value: ",round(Z,2), "\n", "What else?"))

# classic ggplot, with text in aes
p <- ggplot(data, aes(X, Y, fill= Z, text=text)) + 
  geom_tile() +
  theme_ipsum()

ggplotly(p, tooltip="text")
?ggplotly()
# save the widget
# library(htmlwidgets)
# saveWidget(pp, file=paste0( getwd(), "/HtmlWidget/ggplotlyHeatmap.html"))